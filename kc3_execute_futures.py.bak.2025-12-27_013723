#!/usr/bin/env python3
"""
KC3 Futures Executor (USDâ“ˆ-M, fapi.binance.com)

- Reads desired position from: /var/www/bbotpat_live/kc3_latest.json
  expects: {"position":{"side":"LONG|SHORT","token":"UNI"}}

- LIVE_TRADING_KC3=1 => place real orders
  LIVE_TRADING_KC3=0 => dry-run (no orders), but still computes qty and logs actions

- Quote asset / symbol suffix:
    KC3_QUOTE_ASSET=USDC
    KC3_SYMBOL_SUFFIX=USDC
  => token UNI -> symbol UNIUSDC

- Balance logic:
  1) Try /fapi/v2/balance for the specific QUOTE_ASSET row.
  2) If not found or zero, fallback to /fapi/v2/account "availableBalance".
     (This fixes your "avail=0.0" problem while /account shows ~95.)

- Prevents spam:
  Only acts when desired (symbol, side) changes OR when we detect current position differs.

- Telegram notifications:
  Uses TG_BOT_TOKEN and TG_CHAT_ID (same style as KC2).
"""

import os, json, time, hmac, hashlib, urllib.parse
from pathlib import Path
from datetime import datetime, timezone
import requests

KC3_LATEST = Path("/var/www/bbotpat_live/kc3_latest.json")

STATE_DIR = Path("/root/bbotpat_live/data")
STATE_DIR.mkdir(parents=True, exist_ok=True)
EXEC_STATE = STATE_DIR / "kc3_futures_exec_state.json"

BASE_URL = os.getenv("BINANCE_FUTURES_BASE_URL", "https://fapi.binance.com").rstrip("/")
API_KEY  = os.getenv("BINANCE_API_KEY", "").strip()
API_SEC  = os.getenv("BINANCE_API_SECRET", "").strip()

TG_BOT_TOKEN = os.getenv("TG_BOT_TOKEN", "").strip().strip('"').strip("'")
TG_CHAT_ID   = os.getenv("TG_CHAT_ID", "").strip().strip('"').strip("'")

LIVE_TRADING = os.getenv("LIVE_TRADING_KC3", "0").strip().lower() in ("1", "true", "yes")

QUOTE_ASSET  = os.getenv("KC3_QUOTE_ASSET", "USDC").strip().upper()
SYMBOL_SUFFIX= os.getenv("KC3_SYMBOL_SUFFIX", "USDC").strip().upper()

LEVERAGE     = int(float(os.getenv("KC3_LEVERAGE", "1")))
MAX_NOTIONAL = float(os.getenv("KC3_MAX_NOTIONAL", "0"))  # 0 => full available
POLL_SEC     = 2.0

def utc_now_iso():
    return datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")

def log(msg: str):
    print(f"[{utc_now_iso()}] {msg}", flush=True)

def tg_send(text: str):
    if not (TG_BOT_TOKEN and TG_CHAT_ID):
        return
    try:
        url = f"https://api.telegram.org/bot{TG_BOT_TOKEN}/sendMessage"
        requests.post(url, data={"chat_id": TG_CHAT_ID, "text": text}, timeout=10)
    except Exception:
        pass

def require_creds():
    if not API_KEY or not API_SEC:
        raise RuntimeError("Missing BINANCE_API_KEY / BINANCE_API_SECRET in environment")

def _sign(params: dict) -> dict:
    params = dict(params)
    qs = urllib.parse.urlencode(params)
    sig = hmac.new(API_SEC.encode(), qs.encode(), hashlib.sha256).hexdigest()
    params["signature"] = sig
    return params

def _request(method: str, path: str, params=None, signed=False):
    params = params or {}
    headers = {"X-MBX-APIKEY": API_KEY} if API_KEY else {}
    if signed:
        params["timestamp"] = int(time.time() * 1000)
        params["recvWindow"] = 5000
        params = _sign(params)
    url = BASE_URL + path
    r = requests.request(method, url, params=params, headers=headers, timeout=15)
    if r.status_code >= 400:
        raise RuntimeError(f"{method} {path} failed {r.status_code}: {r.text}")
    return r.json()

def account_info():
    # GET /fapi/v2/account (signed)
    return _request("GET", "/fapi/v2/account", signed=True)

def account_balance_list():
    # GET /fapi/v2/balance (signed) => list of assets
    return _request("GET", "/fapi/v2/balance", signed=True)

def position_risk():
    # GET /fapi/v2/positionRisk (signed)
    return _request("GET", "/fapi/v2/positionRisk", signed=True)

def mark_price(symbol: str):
    # GET /fapi/v1/premiumIndex (public)
    return _request("GET", "/fapi/v1/premiumIndex", params={"symbol": symbol}, signed=False)

def set_leverage(symbol: str, lev: int):
    # POST /fapi/v1/leverage (signed)
    return _request("POST", "/fapi/v1/leverage", params={"symbol": symbol, "leverage": lev}, signed=True)

def place_market_order(symbol: str, side: str, qty: float, reduce_only: bool = False):
    # POST /fapi/v1/order (signed)
    params = {
        "symbol": symbol,
        "side": side,  # BUY / SELL
        "type": "MARKET",
        "quantity": qty,
    }
    if reduce_only:
        params["reduceOnly"] = "true"
    return _request("POST", "/fapi/v1/order", params=params, signed=True)

def symbol_from_token(token: str) -> str:
    token = token.strip().upper()
    return f"{token}{SYMBOL_SUFFIX}"

def read_json(path: Path):
    try:
        return json.loads(path.read_text())
    except Exception:
        return None

def write_json(path: Path, obj):
    tmp = path.with_suffix(path.suffix + ".tmp")
    tmp.write_text(json.dumps(obj, indent=2))
    tmp.replace(path)

def load_exec_state():
    st = read_json(EXEC_STATE)
    if not isinstance(st, dict):
        st = {}
    st.setdefault("last_desired_key", None)  # e.g. "UNIUSDC|LONG"
    st.setdefault("last_action_ts", 0.0)
    return st

def save_exec_state(st: dict):
    write_json(EXEC_STATE, st)

def get_current_position_amt(symbol: str) -> float:
    """
    positionRisk returns list; positionAmt is + for long, - for short
    """
    pr = position_risk()
    if isinstance(pr, list):
        for row in pr:
            if str(row.get("symbol", "")).upper() == symbol.upper():
                try:
                    return float(row.get("positionAmt", 0.0))
                except Exception:
                    return 0.0
    return 0.0

def get_available_quote_balance() -> float:
    """
    Fix for your case:
    - First try /fapi/v2/balance specific QUOTE_ASSET row.
    - If not found / is 0, fallback to /fapi/v2/account availableBalance.
    """
    # 1) per-asset list
    try:
        bal = account_balance_list()
        if isinstance(bal, list):
            for row in bal:
                if str(row.get("asset", "")).upper() == QUOTE_ASSET:
                    for k in ("availableBalance", "balance"):
                        vv = row.get(k)
                        if vv is not None:
                            try:
                                v = float(vv)
                                if v > 0:
                                    return v
                            except Exception:
                                pass
    except Exception as e:
        log(f"Warn: /fapi/v2/balance failed: {e}")

    # 2) fallback: account availableBalance (USD-equivalent, works with multi-asset margin)
    try:
        acc = account_info()
        v = float(acc.get("availableBalance", 0.0))
        return v
    except Exception as e:
        log(f"Warn: /fapi/v2/account failed: {e}")

    return 0.0

def compute_qty_from_notional(symbol: str, notional: float) -> float:
    mp = mark_price(symbol)
    px = float(mp.get("markPrice", 0.0))
    if px <= 0:
        raise RuntimeError(f"Bad mark price for {symbol}: {mp}")
    qty = notional / px
    # keep sane precision
    if qty <= 0:
        return 0.0
    return float(f"{qty:.6f}")

def parse_desired():
    doc = read_json(KC3_LATEST)
    if not isinstance(doc, dict):
        return None
    pos = doc.get("position")
    if not isinstance(pos, dict):
        return None
    token = str(pos.get("token", "")).upper().strip()
    side  = str(pos.get("side", "")).upper().strip()  # LONG/SHORT
    if not token or side not in ("LONG", "SHORT"):
        return None
    symbol = symbol_from_token(token)
    return {"symbol": symbol, "side": side}

def main():
    require_creds()
    st = load_exec_state()

    log(f"KC3 Futures Executor starting. LIVE_TRADING_KC3={LIVE_TRADING}")
    log(f"BASE_URL={BASE_URL} QUOTE_ASSET={QUOTE_ASSET} SYMBOL_SUFFIX={SYMBOL_SUFFIX} LEV={LEVERAGE} MAX_NOTIONAL={MAX_NOTIONAL}")

    tg_send(f"KC3 futures executor started. LIVE={LIVE_TRADING} QUOTE={QUOTE_ASSET} SUFFIX={SYMBOL_SUFFIX}")

    last_symbol_for_lev = None

    while True:
        try:
            desired = parse_desired()
            if not desired:
                time.sleep(POLL_SEC)
                continue

            symbol = desired["symbol"]
            side   = desired["side"]
            desired_is_long = (side == "LONG")
            desired_key = f"{symbol}|{side}"

            # leverage once per symbol
            if symbol != last_symbol_for_lev:
                try:
                    if LIVE_TRADING:
                        set_leverage(symbol, LEVERAGE)
                        log(f"Leverage set OK for {symbol} => {LEVERAGE}x")
                    else:
                        # dry-run: still attempt, but don't fail hard
                        try:
                            set_leverage(symbol, LEVERAGE)
                            log(f"(dry-run) leverage set OK for {symbol} => {LEVERAGE}x")
                        except Exception as e:
                            log(f"(dry-run) leverage set failed for {symbol}: {e}")
                except Exception as e:
                    log(f"Warn: leverage set failed for {symbol}: {e}")
                last_symbol_for_lev = symbol

            cur_amt = get_current_position_amt(symbol)
            cur_is_long = (cur_amt > 0)
            cur_is_short = (cur_amt < 0)

            # If we already match desired and desired hasn't changed, do nothing
            if desired_key == st.get("last_desired_key") and ((desired_is_long and cur_is_long) or ((not desired_is_long) and cur_is_short) or (cur_amt == 0.0 and False)):
                time.sleep(POLL_SEC)
                continue

            # Close if opposite position exists
            if cur_amt != 0.0:
                if cur_is_long != desired_is_long:
                    close_side = "SELL" if cur_amt > 0 else "BUY"
                    close_qty  = abs(cur_amt)
                    msg = f"KC3 flip: closing {symbol} amt={cur_amt} via {close_side} qty={close_qty}"
                    log(msg)
                    tg_send(msg)
                    if LIVE_TRADING:
                        place_market_order(symbol, close_side, close_qty, reduce_only=True)
                        log(f"Close sent OK (reduceOnly) {symbol}")
                else:
                    # already in correct direction, just update state and chill
                    st["last_desired_key"] = desired_key
                    save_exec_state(st)
                    time.sleep(POLL_SEC)
                    continue

            # Compute notional (full balance unless capped)
            avail = get_available_quote_balance()
            notional = avail
            if MAX_NOTIONAL > 0:
                notional = min(notional, MAX_NOTIONAL)

            if notional <= 0:
                log(f"Not enough available balance to open (avail={avail}). QUOTE_ASSET={QUOTE_ASSET}")
                time.sleep(POLL_SEC)
                continue

            qty = compute_qty_from_notional(symbol, notional)
            if qty <= 0:
                log(f"Computed qty=0 for {symbol} notional={notional}. Skipping.")
                time.sleep(POLL_SEC)
                continue

            open_side = "BUY" if desired_is_long else "SELL"
            msg = f"KC3 open: {side} {symbol} notional~{notional:.2f} qty~{qty:.6f} LIVE={LIVE_TRADING}"
            log(msg)
            tg_send(msg)

            if LIVE_TRADING:
                place_market_order(symbol, open_side, qty, reduce_only=False)
                log(f"Open sent OK {symbol} {side}")

            st["last_desired_key"] = desired_key
            st["last_action_ts"] = time.time()
            save_exec_state(st)

        except Exception as e:
            emsg = f"KC3 futures ERROR: {e}"
            log(emsg)
            tg_send(emsg)

        time.sleep(POLL_SEC)

if __name__ == "__main__":
    main()
