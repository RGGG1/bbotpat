#!/usr/bin/env python3
import os, time, json, hmac, hashlib, urllib.parse, requests
from datetime import datetime

# =====================
# CONFIG / ENV
# =====================
BASE_URL = os.getenv("BINANCE_FUTURES_BASE_URL", "https://fapi.binance.com").rstrip("/")
API_KEY  = os.getenv("BINANCE_API_KEY")
API_SEC  = os.getenv("BINANCE_API_SECRET")

QUOTE_ASSET   = os.getenv("KC3_QUOTE_ASSET", "USDC")
SYMBOL_SUFFIX = os.getenv("KC3_SYMBOL_SUFFIX", "USDC")
LEVERAGE      = int(os.getenv("KC3_LEVERAGE", "1"))
MAX_NOTIONAL  = float(os.getenv("KC3_MAX_NOTIONAL", "10"))
LIVE_TRADING  = os.getenv("LIVE_TRADING_KC3", "0") == "1"

POLL_SEC = 5
KC3_LATEST = "/var/www/bbotpat_live/kc3_latest.json"

# =====================
# HELPERS
# =====================
def ts():
    return datetime.utcnow().isoformat()+"Z"

def log(msg):
    print(f"[{ts()}] {msg}", flush=True)

def require_creds():
    if not API_KEY or not API_SEC:
        raise RuntimeError("Missing BINANCE_API_KEY or BINANCE_API_SECRET")

def sign(params):
    qs = urllib.parse.urlencode(params)
    return hmac.new(API_SEC.encode(), qs.encode(), hashlib.sha256).hexdigest()

def request(method, path, params=None, signed=False):
    if params is None:
        params = {}

    if signed:
        params["timestamp"] = int(time.time() * 1000)
        params["recvWindow"] = 5000
        params["signature"] = sign(params)

    headers = {"X-MBX-APIKEY": API_KEY} if signed else {}
    r = requests.request(method, BASE_URL + path, params=params, headers=headers, timeout=10)

    if r.status_code != 200:
        raise RuntimeError(f"{method} {path} failed {r.status_code}: {r.text}")

    return r.json()

# =====================
# BINANCE API
# =====================
def set_leverage(symbol, lev):
    return request("POST", "/fapi/v1/leverage",
                   params={"symbol": symbol, "leverage": lev},
                   signed=True)

def account_overview():
    return request("GET", "/fapi/v2/account", signed=True)

def position_risk():
    return request("GET", "/fapi/v2/positionRisk", signed=True)

def mark_price(symbol):
    return request("GET", "/fapi/v1/premiumIndex",
                   params={"symbol": symbol})

def place_market(symbol, side, qty, reduce_only=False):
    params = {
        "symbol": symbol,
        "side": side,
        "type": "MARKET",
        "quantity": qty,
        "reduceOnly": "true" if reduce_only else "false"
    }
    return request("POST", "/fapi/v1/order", params=params, signed=True)

# =====================
# CORE LOGIC
# =====================
def symbol_from_token(tok):
    return f"{tok}{SYMBOL_SUFFIX}"

def get_available_quote_balance():
    acct = account_overview()
    return float(acct.get("availableBalance", 0.0))

def get_current_position_amt(symbol):
    for row in position_risk():
        if row.get("symbol") == symbol:
            return float(row.get("positionAmt", 0.0))
    return 0.0

def compute_qty(symbol, notional):
    mp = mark_price(symbol)
    px = float(mp["markPrice"])
    return float(f"{notional / px:.6f}")

def read_kc3_latest():
    try:
        return json.loads(open(KC3_LATEST).read())
    except Exception:
        return None

# =====================
# MAIN LOOP
# =====================
def main():
    log(f"KC3 Futures Executor starting. LIVE_TRADING={LIVE_TRADING}")
    log(f"BASE={BASE_URL} QUOTE={QUOTE_ASSET} SUFFIX={SYMBOL_SUFFIX} LEV={LEVERAGE}")

    require_creds()
    last_symbol = None

    while True:
        try:
            desired = read_kc3_latest()
            if not desired or not isinstance(desired.get("position"), dict):
                time.sleep(POLL_SEC)
                continue

            token = desired["position"]["token"].upper()
            side  = desired["position"]["side"].upper()
            symbol = symbol_from_token(token)

            if symbol != last_symbol:
                if LIVE_TRADING:
                    set_leverage(symbol, LEVERAGE)
                    log(f"Leverage set {symbol} => {LEVERAGE}x")
                else:
                    log(f"(dry-run) leverage {symbol} => {LEVERAGE}x")
                last_symbol = symbol

            cur_amt = get_current_position_amt(symbol)
            want_long = (side == "LONG")

            if cur_amt != 0:
                cur_long = cur_amt > 0
                if cur_long == want_long:
                    time.sleep(POLL_SEC)
                    continue

                close_side = "SELL" if cur_amt > 0 else "BUY"
                qty = abs(cur_amt)
                log(f"Closing {symbol} qty={qty}")
                if LIVE_TRADING:
                    place_market(symbol, close_side, qty, reduce_only=True)

            avail = get_available_quote_balance()
            if avail <= 0:
                log(f"No available {QUOTE_ASSET} (avail={avail})")
                time.sleep(POLL_SEC)
                continue

            notional = min(avail, MAX_NOTIONAL)
            qty = compute_qty(symbol, notional)
            open_side = "BUY" if want_long else "SELL"

            log(f"Opening {side} {symbol} notional={notional:.2f} qty={qty} LIVE={LIVE_TRADING}")
            if LIVE_TRADING:
                place_market(symbol, open_side, qty)

        except Exception as e:
            log(f"ERROR: {e}")

        time.sleep(POLL_SEC)

if __name__ == "__main__":
    main()
