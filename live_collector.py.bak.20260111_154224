#!/usr/bin/env python3
import json, os, time
from datetime import datetime, timezone
from pathlib import Path
from urllib.request import urlopen, Request
from urllib.parse import urlencode

WEBROOT = Path("/var/www/bbotpat_live")
OUT = WEBROOT / "prices_latest.json"
OUT.parent.mkdir(parents=True, exist_ok=True)

SPOT_URL = "https://api.binance.com/api/v3/ticker/price"
FUT_URL  = "https://fapi.binance.com/fapi/v1/ticker/price"
POLL_SEC = float(os.getenv("LIVE_COLLECTOR_POLL_SEC", "1.0"))

DEFAULT_TOKENS = [
    "UNI","SOL","ETH","BNB","DOGE","TON","SUI",
    "XRP","TRX","ADA","LINK","XMR","XLM","ZEC","LTC","AVAX","HYPE","WLFI",
]

def utc():
    return datetime.now(timezone.utc).isoformat().replace("+00:00","Z")

def norm_tokens(s: str):
    s = (s or "").strip().replace(",", " ")
    s = " ".join(s.split())
    toks = [t.upper() for t in s.split()] if s else []
    # remove SHIB always
    toks = [t for t in toks if t and t != "SHIB"]
    # de-dupe preserve order
    seen=set(); out=[]
    for t in toks:
        if t not in seen:
            out.append(t); seen.add(t)
    return out

def http_get_json(url: str, params: dict):
    qs = urlencode(params)
    req = Request(url + "?" + qs, headers={"User-Agent":"bbotpat-live-collector"})
    with urlopen(req, timeout=10) as r:
        return json.loads(r.read().decode("utf-8"))

def fetch_prices(symbols):
    # Binance accepts ?symbols=["BTCUSDT","ETHUSDT",...]
    payload = {"symbols": json.dumps(symbols)}
    try:
        data = http_get_json(SPOT_URL, payload)
        return data, "spot"
    except Exception:
        data = http_get_json(FUT_URL, payload)
        return data, "futures"

def write_json_atomic(path: Path, obj):
    tmp = path.with_suffix(".tmp")
    tmp.write_text(json.dumps(obj, indent=2) + "\n", encoding="utf-8")
    tmp.replace(path)

def main():
    tokens_env = os.getenv("KC3_ALT_LIST", "")
    toks = norm_tokens(tokens_env) if tokens_env.strip() else DEFAULT_TOKENS[:]
    # ensure core BTC always included in output
    want = ["BTC"] + toks

    # Build USDT symbols (BTCUSDT etc). We do NOT support SHIB here.
    symbols = [f"{t}USDT" for t in want if t != "BTC"]
    symbols = ["BTCUSDT"] + symbols

    last_ok = 0
    while True:
        t0 = time.time()
        rows = [{"token":"BTC", "price": None, "mc": None, "change_24h": None, "btc_dom": None, "range": None, "action": None, "pot_roi_frac": None}]
        mp = {}

        try:
            data, src = fetch_prices(symbols)
            # data is list[{"symbol": "...", "price": "..."}]
            if isinstance(data, list):
                for it in data:
                    sym = it.get("symbol")
                    px = it.get("price")
                    if sym and px is not None:
                        try:
                            mp[sym] = float(px)
                        except Exception:
                            pass

            # Fill BTC price
            btc = mp.get("BTCUSDT")
            if btc:
                rows[0]["price"] = btc

            # Fill alt tokens
            for t in toks:
                sym = f"{t}USDT"
                px = mp.get(sym)
                if px and px > 0:
                    rows.append({
                        "token": t,
                        "price": px,
                        "mc": None,
                        "change_24h": None,
                        "btc_dom": None,
                        "range": None,
                        "action": None,
                        "pot_roi_frac": None
                    })

            missing = [t for t in (["BTC"]+toks) if (t=="BTC" and not rows[0]["price"]) or (t!="BTC" and f"{t}USDT" not in mp)]
            payload = {"timestamp": utc(), "rows": rows, "src": src, "missing": missing}
            write_json_atomic(OUT, payload)
            last_ok = time.time()
        except Exception as e:
            # If fetch fails, still write a heartbeat with empty rows so downstream sees timestamp moving
            payload = {"timestamp": utc(), "rows": [], "src": "error", "err": repr(e)}
            write_json_atomic(OUT, payload)

        dt = time.time() - t0
        sleep_for = max(0.2, POLL_SEC - dt)
        time.sleep(sleep_for)

if __name__ == "__main__":
    main()
