#!/usr/bin/env python3
import os, json, time, math
from pathlib import Path
from datetime import datetime, timezone

# ---- Price helper for prices_latest.json (expects {'rows':[{'token','price'},...]}) ----
def get_px(prices_doc, token: str):
    try:
        token = str(token).upper()
    except Exception:
        return None
    if not isinstance(prices_doc, dict):
        return None
    rows = prices_doc.get('rows')
    if isinstance(rows, list):
        for r in rows:
            if isinstance(r, dict) and str(r.get('token','')).upper() == token:
                try:
                    v = float(r.get('price'))
                    return v if v > 0 else None
                except Exception:
                    return None
    # fallback: sometimes direct mapping exists
    v = prices_doc.get(token)
    try:
        v = float(v)
        return v if v > 0 else None
    except Exception:
        return None
# ---- end price helper ----

PRICES_IN   = Path("/var/www/bbotpat_live/prices_latest.json")
DESIRED_OUT = Path("/root/bbotpat_live/kc3_desired_position.json")

STATE_DIR = Path("/root/bbotpat_live/data")
STATE_DIR.mkdir(parents=True, exist_ok=True)
STATE_PATH = STATE_DIR / "kc3_lag_state.json"

# Loop + sizing
LOOP_SEC     = float(os.getenv("KC3_AGENT_LOOP_SEC", "15"))
USD_NOTIONAL = float(os.getenv("KC3_USD_NOTIONAL", "25"))

# Universe
ALT_LIST = [t.strip().upper() for t in os.getenv("KC3_ALT_LIST", "UNI,SOL,ETH,BNB,DOGE,TON,SUI").split(",") if t.strip()]

# Lag model params
LOOKBACK_SEC = float(os.getenv("KC3_LAG_LOOKBACK_SEC", "900"))   # 15 minutes
Z_ENTER      = float(os.getenv("KC3_LAG_Z_ENTER", "1.2"))        # threshold to enter
Z_EXIT       = float(os.getenv("KC3_LAG_Z_EXIT", "0.3"))          # exit (hysteresis)
SWITCH_DELTA = float(os.getenv("KC3_LAG_SWITCH_DELTA", "0.3"))     # rotate only if better by this
MAX_CANDS    = int(float(os.getenv("KC3_MAX_CANDIDATES", "7")))  # candidates list length

# Direction choice: trade the bigger extreme (leader or laggard)
TRADE_MODE   = os.getenv("KC3_LAG_MODE", "both").lower()         # both|long_only|short_only

def utc():
    return datetime.now(timezone.utc).isoformat().replace("+00:00","Z")

def safe_read_json(p: Path):
    try:
        if not p.exists():
            return None
        return json.loads(p.read_text() or "null")
    except Exception:
        return None

def safe_write_json(p: Path, obj: dict):
    tmp = p.with_suffix(".tmp")
    tmp.write_text(json.dumps(obj, indent=2) + "\n")
    tmp.replace(p)

def safe_unlink(p: Path):
    try:
        p.unlink()
    except FileNotFoundError:
        pass
    except Exception:
        pass

def load_state():
    st = safe_read_json(STATE_PATH)
    if not isinstance(st, dict):
        st = {}
    st.setdefault("history", [])  # list of {"t": epoch, "rel": {tok: log(alt/btc)}}
    return st

def save_state(st: dict):
    safe_write_json(STATE_PATH, st)

def build_snapshot(prices_doc):
    # Build rel[tok] = log(alt/btc)
    btc = get_px(prices_doc, 'BTC')
    if not btc or btc <= 0:
        return None
    rel = {}
    for tok in ALT_LIST:
        p = get_px(prices_doc, tok)
        if p and p > 0:
            rel[tok] = math.log(p / btc)
    # require enough symbols to avoid junk signals
    if len(rel) < max(2, int(len(ALT_LIST) * 0.6)):
        return None
    return rel

def prune_history(hist: list, now: float):
    cutoff = now - LOOKBACK_SEC
    # keep at least 2 points if possible
    out = [h for h in hist if isinstance(h, dict) and float(h.get("t", 0)) >= cutoff]
    return out

def compute_returns(hist: list):
    # return over window = latest - oldest
    if len(hist) < 2:
        return None
    oldest = hist[0].get("rel") or {}
    latest = hist[-1].get("rel") or {}
    rets = {}
    for tok in ALT_LIST:
        if tok in oldest and tok in latest:
            rets[tok] = float(latest[tok]) - float(oldest[tok])
    if len(rets) < 2:
        return None
    return rets

def mean_std(vals):
    xs = list(vals)
    if len(xs) < 2:
        return (0.0, 0.0)
    m = sum(xs) / len(xs)
    v = sum((x - m) ** 2 for x in xs) / (len(xs) - 1)
    s = math.sqrt(v) if v > 0 else 0.0
    return (m, s)

def main():
    print(f"[{utc()}] KC3 LAG agent started | alts={ALT_LIST} lookback_sec={LOOKBACK_SEC} z_enter={Z_ENTER} loop={LOOP_SEC}s", flush=True)
    st = load_state()
    st.setdefault('pos_active', False)

    while True:
        try:
            prices_doc = safe_read_json(PRICES_IN)
            prices_ts = (prices_doc.get('timestamp') if isinstance(prices_doc, dict) else None) or utc()
            if not isinstance(prices_doc, dict):
                print(f"[{utc()}] prices_latest missing/invalid", flush=True)
                time.sleep(LOOP_SEC)
                continue

            now = time.time()
            rel = build_snapshot(prices_doc)
            if rel is None:
                print(f"[{utc()}] insufficient prices to compute rel alt/btc", flush=True)
                time.sleep(LOOP_SEC)
                continue

            hist = st.get("history") or []
            hist.append({"t": now, "rel": rel})
            hist = prune_history(hist, now)
            st["history"] = hist

            rets = compute_returns(hist)
            if rets is None:
                save_state(st)
                print(f"[{utc()}] warming up history ({len(hist)} pts)", flush=True)
                time.sleep(LOOP_SEC)
                continue

            m, s = mean_std(rets.values())
            if s <= 0:
                save_state(st)
                # zero dispersion: emit FLAT so executor can close / stay flat
                    # --- determine ENTER vs HOLD based on agent-side position state ---
    reason = 'enter' if not st.get('pos_active') else 'hold'
desired = {
                    "side": "FLAT",
                    "symbol": "",
                    "notional_usd": float(USD_NOTIONAL),
                    "timestamp": utc(),
                    "src": "lag_selector",
                    "reason": "zero_dispersion",
                    "alt_list": ALT_LIST,
                    "prices_ts": (prices_doc.get("timestamp") if isinstance(prices_doc, dict) else None) or utc(),
                    "candidates": [f"{tok}USDT" for tok in ALT_LIST],
                }
                safe_write_json(DESIRED_OUT, desired)
                print(f"[{utc()}] zero dispersion; FLAT", flush=True)
                time.sleep(LOOP_SEC)
                continue

            z = {tok: (ret - m) / s for tok, ret in rets.items()}
            # --- HYSTERESIS+ROTATION decision engine (avoids chop) ---
            held = st.get('held') if isinstance(st, dict) else None
            if not isinstance(held, dict):
                held = {'symbol': '', 'side': ''}
            st['held'] = held
            
            # candidates sorted for each direction
            laggards = sorted(z.items(), key=lambda kv: kv[1])                 # most negative first
            leaders  = sorted(z.items(), key=lambda kv: kv[1], reverse=True)   # most positive first
            best_long_tok, best_long_z   = laggards[0]
            best_short_tok, best_short_z = leaders[0]
            
            # pick best side per TRADE_MODE
            chosen_side = None
            chosen_tok  = None
            chosen_z    = 0.0
            if TRADE_MODE == 'long_only':
                chosen_side, chosen_tok, chosen_z = 'LONG', best_long_tok, float(best_long_z)
            elif TRADE_MODE == 'short_only':
                chosen_side, chosen_tok, chosen_z = 'SHORT', best_short_tok, float(best_short_z)
            else:
                # trade the bigger extreme
                if abs(best_short_z) >= abs(best_long_z):
                    chosen_side, chosen_tok, chosen_z = 'SHORT', best_short_tok, float(best_short_z)
                else:
                    chosen_side, chosen_tok, chosen_z = 'LONG', best_long_tok, float(best_long_z)
            
            desired = None
            held_symbol = str(held.get('symbol') or '')
            held_side   = str(held.get('side') or '').upper()
            held_tok    = held_symbol.replace('USDT','') if held_symbol.endswith('USDT') else held_symbol
            held_z      = float(z.get(held_tok)) if held_tok in z else None
            
            def emit_flat(reason):
                nonlocal desired
                held['symbol'] = ''
                held['side'] = ''
                desired = {
                    'side': 'FLAT',
                    'symbol': '',
                    'notional_usd': float(USD_NOTIONAL),
                    'timestamp': utc(),
                    'src': 'lag_selector',
                    'reason': reason,
                    'alt_list': ALT_LIST,
                    'prices_ts': prices_ts,
                    'candidates': [f"{tok}USDT" for tok in ALT_LIST],
                }
            
            def emit_hold(reason):
                nonlocal desired
                desired = {
                    'side': held_side,
                    'symbol': held_symbol,
                    'notional_usd': float(USD_NOTIONAL),
                    'timestamp': utc(),
                    'src': 'lag_selector',
                    'reason': reason,
                    'alt_list': ALT_LIST,
                    'prices_ts': prices_ts,
                    'z_score': float(held_z) if held_z is not None else None,
                    'candidates': [f"{tok}USDT" for tok in ( [t for t,_ in laggards[:MAX_CANDS]] if held_side=='LONG' else [t for t,_ in leaders[:MAX_CANDS]] )],
                }
            
            def emit_switch(side, tok, zval, reason):
                nonlocal desired
                sym = f"{tok}USDT"
                held['symbol'] = sym
                held['side'] = side
                cands = [f"{t}USDT" for t,_ in (laggards[:MAX_CANDS] if side=='LONG' else leaders[:MAX_CANDS])]
                desired = {
                    'side': side,
                    'symbol': sym,
                    'notional_usd': float(USD_NOTIONAL),
                    'timestamp': utc(),
                    'src': 'lag_selector',
                    'reason': reason,
                    'alt_list': ALT_LIST,
                    'prices_ts': prices_ts,
                    'z_score': float(zval),
                    'candidates': cands,
                }
            
            # --- decision rules ---
            if not held_symbol or held_side not in ('LONG','SHORT'):
                # no position: only enter on Z_ENTER
                if abs(chosen_z) >= Z_ENTER:
                    emit_switch(chosen_side, chosen_tok, chosen_z, 'enter')
                    print(f"[{utc()}] SIGNAL {chosen_side} {chosen_tok}USDT z={chosen_z:.3f}", flush=True)
                else:
                    emit_flat('below_entry')
                    print(f"[{utc()}] FLAT below_entry best={chosen_tok} z={chosen_z:.3f}", flush=True)
            else:
                # have a position: exit only on Z_EXIT or rotate only if clearly better
                if held_z is None:
                    emit_flat('held_missing')
                    print(f"[{utc()}] FLAT held_missing held={held_symbol}", flush=True)
                elif abs(held_z) <= Z_EXIT:
                    emit_flat('exit_hysteresis')
                    print(f"[{utc()}] FLAT exit_hysteresis held={held_symbol} z={held_z:.3f}", flush=True)
                else:
                    # consider rotation
                    new_sym = f"{chosen_tok}USDT"
                    if new_sym != held_symbol and abs(chosen_z) >= Z_ENTER and abs(chosen_z) >= abs(held_z) + SWITCH_DELTA:
                        emit_switch(chosen_side, chosen_tok, chosen_z, 'rotate')
                        print(f"[{utc()}] ROTATE {held_symbol}->{new_sym} held_z={held_z:.3f} new_z={chosen_z:.3f}", flush=True)
                    else:
                        emit_hold('hold')
                        print(f"[{utc()}] HOLD {held_symbol} z={held_z:.3f} best={chosen_tok} z={chosen_z:.3f}", flush=True)
            
            safe_write_json(DESIRED_OUT, desired)
            save_state(st)
            time.sleep(LOOP_SEC)
            continue
            # --- end hysteresis+rotation engine ---

            # candidates sorted for each direction
            laggards = sorted(z.items(), key=lambda kv: kv[1])                 # most negative first
            leaders  = sorted(z.items(), key=lambda kv: kv[1], reverse=True)   # most positive first

            best_long_tok, best_long_z = laggards[0]
            best_short_tok, best_short_z = leaders[0]

            chosen_side = None
            chosen_tok  = None

            if TRADE_MODE == "long_only":
                if best_long_z <= -Z_ENTER:
                    chosen_side, chosen_tok = "LONG", best_long_tok
            elif TRADE_MODE == "short_only":
                if best_short_z >= Z_ENTER:
                    chosen_side, chosen_tok = "SHORT", best_short_tok
            else:
                # both: take bigger absolute extreme
                long_ok  = best_long_z <= -Z_ENTER
                short_ok = best_short_z >= Z_ENTER
                if long_ok or short_ok:
                    if long_ok and short_ok:
                        # choose larger magnitude
                        if abs(best_short_z) > abs(best_long_z):
                            chosen_side, chosen_tok = "SHORT", best_short_tok
                        else:
                            chosen_side, chosen_tok = "LONG", best_long_tok
                    elif long_ok:
                        chosen_side, chosen_tok = "LONG", best_long_tok
                    else:
                        chosen_side, chosen_tok = "SHORT", best_short_tok

            prices_ts = prices_doc.get("timestamp")

            if not chosen_side:
                # no trade zone: go flat (explicit FLAT signal so executor can close)
                desired = {
                    "side": "FLAT",
                    "symbol": "",
                    "notional_usd": float(USD_NOTIONAL),
                    "timestamp": utc(),
                    "src": "lag_selector",
                    "reason": "no_trade_zone",
                    "alt_list": ALT_LIST,
                    "prices_ts": (prices_doc.get("timestamp") if isinstance(prices_doc, dict) else None) or utc(),
                }
                safe_write_json(DESIRED_OUT, desired)
                st["last_signal"] = None
                st["last_note"] = "no_signal"
                save_state(st)
                print(f"[{utc()}] NO SIGNAL | best_long_z={best_long_z:.3f} best_short_z={best_short_z:.3f} prices_ts={prices_ts}", flush=True)
                time.sleep(LOOP_SEC)
                continue

            # build candidates list for fallback if primary fails
            if chosen_side == "LONG":
                cand = [f"{tok}USDT" for tok, _ in laggards[:MAX_CANDS]]
                score = float(best_long_z)
            else:
                cand = [f"{tok}USDT" for tok, _ in leaders[:MAX_CANDS]]
                score = float(best_short_z)

            desired = {
                "side": chosen_side,
                "symbol": f"{chosen_tok}USDT",
                "candidates": cand,
                "notional_usd": float(USD_NOTIONAL),
                "timestamp": utc(),
                "src": "lag_selector",
                "prices_ts": (prices_doc.get("timestamp") if isinstance(prices_doc, dict) else None) or utc(),
                "lookback_sec": float(LOOKBACK_SEC),
                "z_enter": float(Z_ENTER),
                "z_score": score,
                "best_long": {"token": best_long_tok, "z": float(best_long_z)},
                "best_short": {"token": best_short_tok, "z": float(best_short_z)},
                "alts": ALT_LIST,
            }

            safe_write_json(DESIRED_OUT, desired)
            st["last_signal"] = [desired["symbol"], desired["side"]]
            st["last_note"] = "signal_written"
            save_state(st)

            print(f"[{utc()}] SIGNAL {chosen_side} {desired['symbol']} z={score:.3f} c0={cand[:3]} prices_ts={prices_ts}", flush=True)

        except Exception as e:
            print(f"[{utc()}] ERROR {type(e).__name__}: {e}", flush=True)

        time.sleep(LOOP_SEC)

if __name__ == "__main__":
    main()
