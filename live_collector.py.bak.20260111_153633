#!/usr/bin/env python3
import json, os, time
from datetime import datetime, timezone
from pathlib import Path
from urllib.request import urlopen, Request
from urllib.parse import urlencode

WEBROOT = Path("/var/www/bbotpat_live")
OUT = WEBROOT / "prices_latest.json"
OUT.parent.mkdir(parents=True, exist_ok=True)

# Pull token universe from env if present, else default
# Expect space-separated like: "UNI SOL ETH ..."
TOKENS_ENV = os.getenv("KC3_ALT_LIST", "").strip()
# Accept comma-separated or space-separated lists
TOKENS_ENV = TOKENS_ENV.replace(",", " ")
TOKENS_ENV = " ".join(TOKENS_ENV.split())

DEFAULT_TOKENS = [
    "UNI","SOL","ETH","BNB","DOGE","TON","SUI",
    "XRP","TRX","ADA","LINK","XMR","XLM","ZEC","LTC","AVAX","HYPE","SHIB","WLFI",
]

TOKENS = [t.upper() for t in (TOKENS_ENV.split() if TOKENS_ENV else DEFAULT_TOKENS)]

# Binance symbol overrides:
# - SHIB spot is typically 1000SHIBUSDT; convert to per-1 SHIB by dividing by 1000
TOKEN_SYMBOL_OVERRIDE = {
    "SHIB": ("1000SHIBUSDT", 1000.0),
}

SPOT_URL = "https://api.binance.com/api/v3/ticker/price"
FUT_URL  = "https://fapi.binance.com/fapi/v1/ticker/price"

POLL_SEC = float(os.getenv("LIVE_COLLECTOR_POLL_SEC", "1.0"))

def utc():
    return datetime.now(timezone.utc).isoformat().replace("+00:00","Z")

def http_get_json(url: str, params: dict | None = None, timeout: float = 10.0):
    if params:
        url = url + "?" + urlencode(params)
    req = Request(url, headers={"User-Agent": "bbotpat-live-collector/1.0"})
    with urlopen(req, timeout=timeout) as r:
        return json.loads(r.read().decode("utf-8", errors="replace"))

def atomic_write_json(path: Path, obj: dict):
    tmp = path.with_suffix(".tmp")
    tmp.write_text(json.dumps(obj, indent=2) + "\n")
    tmp.replace(path)

def fetch_prices(url: str, symbols: list[str]) -> dict[str, float]:
    # Binance returns list of {symbol, price}
    data = http_get_json(url, params={"symbols": json.dumps(symbols)})
    out = {}
    if isinstance(data, list):
        for it in data:
            try:
                sym = str(it.get("symbol")).upper()
                px  = float(it.get("price"))
                out[sym] = px
            except Exception:
                continue
    return out

def main():
    # Build Binance symbols list: BTC + tokens
    want_tokens = ["BTC"] + TOKENS
    symbols = []
    token_to_symbol_scale = {}

    for t in want_tokens:
        sym, scale = TOKEN_SYMBOL_OVERRIDE.get(t, (f"{t}USDT", 1.0))
        symbols.append(sym)
        token_to_symbol_scale[t] = (sym, float(scale))

    while True:
        ts = utc()
        merged = {}

        # Spot first
        try:
            merged.update(fetch_prices(SPOT_URL, symbols))
        except Exception:
            pass

        # Futures fallback for any missing
        missing = [sym for sym in symbols if sym not in merged]
        if missing:
            try:
                merged.update(fetch_prices(FUT_URL, missing))
            except Exception:
                pass

        # Build rows
        rows = []
        for t in want_tokens:
            sym, scale = token_to_symbol_scale[t]
            px = merged.get(sym)
            if px is not None:
                try:
                    px = float(px) / float(scale)
                except Exception:
                    px = None
            rows.append({
                "token": t,
                "price": px,
                "mc": None,
                "change_24h": None,
                "btc_dom": None,
                "range": None,
                "action": None,
                "pot_roi_frac": None
            })

        payload = {"timestamp": ts, "rows": rows}
        atomic_write_json(OUT, payload)
        time.sleep(POLL_SEC)

if __name__ == "__main__":
    main()
