<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>HiveAI - All signal, no noise</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/svg+xml" href="favicon.svg" />
  <style>
    :root {
      --bg: #000000;
      --bg-elevated: #050509;
      --border-subtle: #22232f;
      --text-main: #f5f5f7;
      --text-muted: #888aa0;
      --accent-red: #ff4b5c;
      --accent-green: #4dff88;
      --accent-neutral: #ffffff;
      --font-main: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
                   "Inter", "Segoe UI", sans-serif;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: var(--bg);
      color: var(--text-main);
      font-family: var(--font-main);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 24px 16px;
    }

    .app-shell {
      width: 100%;
      max-width: 1040px;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
    }

    .title-stack {
      display: flex;
      align-items: baseline;
      gap: 6px;
      font-size: 22px;
      font-weight: 600;
      letter-spacing: 0.03em;
    }

    .logo-slash {
      font-size: 24px;
      line-height: 1;
      transition: color 0.28s ease;
    }

    .logo-hive {
      transition: color 0.28s ease;
    }

    .logo-ai {
      color: var(--text-main);
      opacity: 0.9;
    }

    .logo-accent-red {
      color: var(--accent-red);
    }

    .logo-accent-green {
      color: var(--accent-green);
    }

    .logo-accent-neutral {
      color: var(--accent-neutral);
    }

    .meta-topline {
      text-align: right;
      font-size: 11px;
      color: var(--text-muted);
    }

	.meta-oracle-link {
    	margin-top: 4px;
	}

    main {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .card {
      background: var(--bg-elevated);
      border-radius: 8px;
      border: 1px solid var(--border-subtle);
      box-shadow: 0 14px 40px rgba(0, 0, 0, 0.45);
      padding: 10px 12px 12px;
    }

    .card-header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      margin-bottom: 6px;
    }

    .card-title {
      font-size: 12px;
      font-weight: 500;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .card-oracle-link {
      font-size: 10px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      text-decoration: none;
      color: var(--text-muted);
      white-space: nowrap;
    }

    .card-oracle-link:hover {
      color: var(--accent-green);
    }

    /* HMI section */
    .hmi-card {
      padding-top: 12px;
      padding-bottom: 14px;
    }

    .hmi-header-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .hmi-value-row {
      display: flex;
      align-items: baseline;
      gap: 10px;
      justify-content: flex-start;
      margin-bottom: 10px;
    }

    .hmi-value {
      font-size: 36px;
      font-weight: 600;
      line-height: 1;
    }

    .hmi-status {
      font-size: 14px;
      font-weight: 500;
      color: var(--accent-neutral);
      text-transform: none;
      opacity: 0.95;
    }

    .hmi-tracking {
      text-align: center;
      margin-top: 4px;
    }

    .hmi-tracking-items {
      font-size: 11px;
      color: var(--text-muted);
      display: inline-flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .hmi-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: var(--accent-green);
      box-shadow: 0 0 6px rgba(77, 255, 136, 0.7);
    }

    /* Dominance / Oracle */
    .oracle-card {
      margin-top: 2px;
      position: relative;
    }

    .oracle-header-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 8px;
    }

    .oracle-header-right {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: nowrap;
      margin-left: auto;
    }

    .oracle-pill-wrapper {
      position: relative;
    }

    .oracle-pill {
      display: inline-flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid #33334a;
      background: #080814;
      cursor: pointer;
      min-width: 96px;
      font-size: 11px;
      color: var(--text-main);
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.4);
    }

    .oracle-pill-label {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .oracle-pill-arrow {
      font-size: 9px;
      opacity: 0.8;
    }

    .oracle-vs {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
    }

    .oracle-dropdown {
      position: absolute;
      top: calc(100% + 4px);
      left: 0;
      z-index: 20;
      background: #050509;
      border-radius: 10px;
      border: 1px solid #33334a;
      box-shadow: 0 14px 40px rgba(0, 0, 0, 0.7);
      padding: 6px 6px 6px;
      min-width: 160px;
      max-height: 260px;
      overflow-y: auto;
      display: none;
    }

    .oracle-dropdown.open {
      display: block;
    }

    .oracle-option {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 6px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 11px;
      color: var(--text-main);
    }

    .oracle-option:hover {
      background: #121224;
    }

    .oracle-option input[type="checkbox"] {
      display: none;
    }

    .oracle-option-box {
      width: 14px;
      height: 14px;
      border-radius: 4px;
      border: 1px solid #44445a;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: var(--accent-green);
    }

    .oracle-option.selected .oracle-option-box {
      background: #101f16;
      border-color: #1f9f4a;
    }

    .oracle-option-tick {
      display: none;
    }

    .oracle-option.selected .oracle-option-tick {
      display: block;
    }

    .oracle-option-label {
      white-space: nowrap;
    }

    .oracle-clear {
      margin-top: 6px;
      padding: 4px 6px;
      text-align: right;
      font-size: 10px;
      color: var(--text-muted);
      border-top: 1px solid #222238;
      cursor: pointer;
    }

    .oracle-clear:hover {
      color: var(--accent-neutral);
    }

    .oracle-main-line {
      font-size: 16px;
      font-weight: 500;
      margin-bottom: 4px;
    }

    .oracle-main-line .dom-value {
      font-size: 36px;
      font-weight: 600;
      margin-right: 6px;
    }

    .oracle-main-line .dom-label {
      font-size: 13px;
      color: var(--accent-neutral);
    }

    .oracle-sub-line,
.oracle-range-line {
    font-size: 14px;
    color: var(--text-muted);
    margin-top: 2px;
}

.oracle-note,
.oracle-error {
    font-size: 11px;
    color: var(--text-muted);
    margin-top: 2px;
}


    .oracle-sub-line span,
    .oracle-range-line span {
      color: var(--text-main);
    }

    .oracle-note {
      margin-top: 4px;
      font-style: italic;
    }

    .oracle-error {
      color: var(--accent-red);
      margin-top: 4px;
    }

    /* Prices table */
    .prices-card {
      margin-top: 4px;
    }

    .prices-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
      margin-top: 6px;
    }

    .prices-table thead {
      border-bottom: 1px solid var(--border-subtle);
    }

    .prices-table th,
    .prices-table td {
      padding: 6px 4px;
    }

    .prices-table th {
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.07em;
      font-size: 10px;
      color: var(--text-muted);
    }

    .prices-table th.token-col,
    .prices-table td.token-col {
      text-align: left;
    }

    .prices-table th.center,
    .prices-table td.center {
      text-align: center;
    }

    .prices-table tbody tr {
      border-bottom: 1px solid #11111a;
    }

    .prices-table tbody tr:last-child {
      border-bottom: none;
    }

    .prices-table tbody tr:nth-child(even) {
      background: #070711;
    }

    .prices-table tbody tr:nth-child(odd) {
      background: #050509;
    }

    .price-positive {
      color: var(--accent-green);
    }

    .price-negative {
      color: var(--accent-red);
    }

    .price-neutral {
      color: var(--text-main);
    }

    .footer-note {
      margin-top: 14px;
      font-size: 11px;
      color: var(--text-muted);
      line-height: 1.5;
    }

    .footer-note-title {
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 10px;
      margin-bottom: 2px;
    }

    .oracle-notes-card {
      margin-top: 4px;
    }

    /* Knifecatcher card */
    .knifecatcher-card {
      position: relative;
    }

    .kc-row {
      display: flex;
      align-items: flex-end;
      gap: 14px;
      margin-top: 8px;
      flex-wrap: wrap;
    }

    .kc-row-secondary {
      margin-top: 12px;
      padding-top: 8px;
      border-top: 1px solid var(--border-subtle);
    }


    .kc-block {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }

    .kc-label {
      font-size: 10px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .kc-main-value {
      font-size: 32px;
      font-weight: 600;
      line-height: 1.1;
    }

    .kc-subline {
      font-size: 11px;
      color: var(--text-muted);
    }

    .kc-secondary-value {
      font-size: 12px;
      line-height: 1.4;
      color: var(--text-muted);
      margin-top: 6px;
    }


    .kc-divider {
      width: 1px;
      align-self: stretch;
      background: linear-gradient(
        to bottom,
        transparent,
        rgba(255, 255, 255, 0.1),
        transparent
      );
    }

    @media (max-width: 700px) {
      .kc-row {
        flex-direction: column;
        align-items: flex-start;
      }

      .kc-divider {
        width: 100%;
        height: 1px;
      }

      .kc-main-value {
        font-size: 26px;
      }
    }

    @media (max-width: 700px) {
      .prices-table {
        font-size: 11px;
      }
      .prices-table th,
      .prices-table td {
        padding: 5px 3px;
      }
      .hmi-value {
        font-size: 32px;
      }
      .oracle-main-line .dom-value {
        font-size: 32px;
      }
      .oracle-dropdown {
        left: 0;
        right: 0;
      }
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <header>
      <div class="title-stack">
        <span id="logo-slash" class="logo-slash logo-accent-neutral">/</span>
        <span class="logo-wordmark">
          <span id="logo-hive" class="logo-hive logo-accent-neutral">Hive</span><span class="logo-ai">AI</span>
        </span>
      </div>
      <div class="meta-topline">
        Updated: <span id="meta-date">--/--/-- --:--</span>
	<div class="meta-oracle-link">
        	<a href="oracle.html" class="card-oracle-link">HiveAI Oracle →</a>
    	</div>
      </div>
    </header>

    <main>
      <!-- HMI CARD -->
      <section class="card hmi-card">
        <div class="hmi-header-row">
          <div class="card-title">Hive Mind Index</div>
        </div>
        <div class="hmi-value-row">
          <div class="hmi-value" id="hmi-value">--.-</div>
          <div class="hmi-status" id="hmi-status">–</div>
        </div>
        <div class="hmi-tracking">
          <div class="hmi-tracking-items">
            <span class="hmi-dot" aria-hidden="true"></span><span>Open interest</span>
            <span class="hmi-dot" aria-hidden="true"></span><span>Perps vs spot</span>
            <span class="hmi-dot" aria-hidden="true"></span><span>Volatility</span>
          </div>
        </div>
      </section>

      <!-- DOMINANCE -->
      <section class="card oracle-card">
        <div class="oracle-header-row">
          <div class="card-title">Dominance</div>
          <div class="oracle-header-right">
            <div class="oracle-pill-wrapper">
              <div class="oracle-pill" id="oracle-x-pill">
                <span class="oracle-pill-label" id="oracle-x-label">Select</span>
                <span class="oracle-pill-arrow">▾</span>
              </div>
              <div class="oracle-dropdown" id="oracle-x-menu"></div>
            </div>
            <span class="oracle-vs">vs</span>
            <div class="oracle-pill-wrapper">
              <div class="oracle-pill" id="oracle-y-pill">
                <span class="oracle-pill-label" id="oracle-y-label">Select</span>
                <span class="oracle-pill-arrow">▾</span>
              </div>
              <div class="oracle-dropdown" id="oracle-y-menu"></div>
            </div>
          </div>
        </div>

        <div class="oracle-main-line" id="oracle-main-line">
          <span class="dom-value">--</span>
          <span class="dom-label">Select X and Y</span>
        </div>
        <div class="oracle-sub-line" id="oracle-sub-line">
          Market caps: <span>–</span>
        </div>
        <div class="oracle-range-line" id="oracle-range-line">
          Range: <span>–</span>
        </div>
        <div class="oracle-error" id="oracle-error"></div>
        </section>

      <!-- KNIFECATCHER -->
                  <section class="card knifecatcher-card">
        <div class="card-header">
          <div class="card-title">Knifecatcher</div>
        </div>

        <!-- Knifecatcher #1: existing rebalancer -->
        <div class="kc-row">
          <div class="kc-block">
            <div class="kc-label">Knifecatcher #1 Balance</div>
            <div class="kc-main-value" id="kc-balance">$--.--</div>
          </div>

          <div class="kc-divider" aria-hidden="true"></div>

          <div class="kc-block kc-block-right">
            <div class="kc-label">Knifecatcher #1 ROI</div>
            <div class="kc-main-value" id="kc-compare">--.--% vs --.--%</div>
            <div class="kc-subline">Rebalancer vs BTC buy and hold</div>
          </div>
        </div>

        <!-- Knifecatcher #2: DOM hourly model (sim) -->
        <div class="kc-row kc-row-secondary">
          <div class="kc-block">
            <div class="kc-label">Knifecatcher #2 Balance</div>
            <div class="kc-main-value" id="kc2-balance">$--.--</div>
          </div>

          <div class="kc-divider" aria-hidden="true"></div>

          <div class="kc-block kc-block-right">
            <div class="kc-label">Knifecatcher #2 ROI</div>
            <div class="kc-main-value" id="kc2-roi">--.--%</div>
            <div class="kc-subline" id="kc2-subline">DOM hourly model (sim)</div>
          </div>
        </div>
      </section>



      <!-- PRICES / TOKENS CARD -->
      <section class="card prices-card">
        <div class="card-header">
          <div class="card-title">Tokens</div>
        </div>
        <table class="prices-table">
          <thead>
            <tr>
              <th class="token-col">Token</th>
              <th class="center">Price</th>
              <th class="center">24h</th>
              <th class="center">Dom</th>
              <th class="center">Range</th>
              <th class="center">Action</th>
            </tr>
          </thead>
          <tbody id="prices-tbody">
          </tbody>
        </table>
      </section>

      <!-- HIVEAI ORACLE NOTES CARD -->
      <section class="card oracle-notes-card">
        <div class="footer-note">
          <div class="footer-note-title">HiveAI Oracle Notes</div>
          <div>
            <ul style="margin-top:6px;line-height:1.35;list-style:disc;padding-left:18px;">
              <li>Hive Mind Index (HMI) is our custom fear and greed index, factored for predictive signaling.</li>
              <li>HMI and Dom values updated hourly.</li>
              <li>'Dom' represents BTC dominance against token.</li>
              <li>'Range' represents up to 2-year BTC Dom range against token.</li>
              <li>USDTC = USDT and USDC combined.</li>
              <li>Additional token listing available on request.</li>
            </ul>
          </div>
        </div>
      </section>
    </main>
  </div>

  <script>
    const HMI_NEUTRAL_LOW = 40;
    const HMI_NEUTRAL_HIGH = 60;

    const ORACLE_TOKENS = [
      "BTC",
      "ETH",
      "BNB",
      "SOL",
      "DOGE",
      "TON",
      "SUI",
      "UNI"
    ];

    const BINANCE_SYMBOLS = {
      BTC: "BTCUSDT",
      ETH: "ETHUSDT",
      BNB: "BNBUSDT",
      SOL: "SOLUSDT",
      DOGE: "DOGEUSDT",
      TON: "TONUSDT",
      SUI: "SUIUSDT",
      UNI: "UNIUSDT"
    };

    let pricesRowsGlobal = [];
    let suppliesGlobal = null;
    let domMc
History = [];  // full daily market cap history (730 days)
    let domBandsGlobal = null;

    let oracleSelectedX = ["BTC"];   // default
    let oracleSelectedY = ["ALTS"];  // default: all alts (not BTC)

    function formatDateTime(ts) {
      if (!ts) return "--/--/-- --:--";
      const d = new Date(ts);
      const dd = String(d.getDate()).padStart(2, "0");
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const yy = String(d.getFullYear()).slice(-2);
      const hh = String(d.getHours()).padStart(2, "0");
      const mi = String(d.getMinutes()).padStart(2, "0");
      return `${dd}/${mm}/${yy} ${hh}:${mi}`;
    }

    function formatMC(v) {
      if (!v || v <= 0) return "$0";
      if (v >= 1e12) {
        return `$${(v / 1e12).toFixed(1)}T`;
      }
      if (v >= 1e9) {
        return `$${Math.round(v / 1e9)}B`;
      }
      if (v >= 1e6) {
        return `$${Math.round(v / 1e6)}M`;
      }
      return `$${Math.round(v).toLocaleString()}`;
    }

    function updateLogoColor(hmi) {
      const slashEl = document.getElementById("logo-slash");
      const hiveEl = document.getElementById("logo-hive");

      if (!slashEl || !hiveEl) return;

      slashEl.classList.remove("logo-accent-red", "logo-accent-green", "logo-accent-neutral");
      hiveEl.classList.remove("logo-accent-red", "logo-accent-green", "logo-accent-neutral");

      if (typeof hmi !== "number" || Number.isNaN(hmi)) {
        slashEl.classList.add("logo-accent-neutral");
        hiveEl.classList.add("logo-accent-neutral");
        return;
      }

      if (hmi < HMI_NEUTRAL_LOW) {
        slashEl.classList.add("logo-accent-red");
        hiveEl.classList.add("logo-accent-red");
      } else if (hmi > HMI_NEUTRAL_HIGH) {
        slashEl.classList.add("logo-accent-green");
        hiveEl.classList.add("logo-accent-green");
      } else {
        slashEl.classList.add("logo-accent-neutral");
        hiveEl.classList.add("logo-accent-neutral");
      }
    }

    // UPDATED BANDS FOR FRONTEND
    function hmiBandLabel(hmi) {
      if (hmi < 10) return "Zombie Apocalypse";
      if (hmi < 25) return "McDonald's Applications in high demand";
      if (hmi < 45) return "NGMI";
      if (hmi < 50) return "Leaning bearish";
      if (hmi < 55) return "Cautiously bullish";
      if (hmi < 75) return "It's digital gold";
      if (hmi < 90) return "Frothy";
      return "It's the future of finance";
    }

    async function fetchHMI() {
      try {
        const resp = await fetch("hmi_latest.json", { cache: "no-store" });
        if (!resp.ok) throw new Error("HMI fetch failed");
        const data = await resp.json();

        const hmiRaw = (typeof data.hmi === "number") ? data.hmi : parseFloat(data.hmi);
        const hmi = Number.isNaN(hmiRaw) ? null : hmiRaw;

        if (hmi === null) {
          throw new Error("Invalid HMI in JSON");
        }

        const hmiEl = document.getElementById("hmi-value");
        const statusEl = document.getElementById("hmi-status");
        if (hmiEl) hmiEl.textContent = hmi.toFixed(1);
        if (statusEl) statusEl.textContent = hmiBandLabel(hmi);

        updateLogoColor(hmi);
      } catch (err) {
        console.error("HMI error:", err);
        const hmiEl = document.getElementById("hmi-value");
        const statusEl = document.getElementById("hmi-status");
        if (hmiEl) hmiEl.textContent = "--.-";
        if (statusEl) statusEl.textContent = "unavailable";
        updateLogoColor(NaN);
      }
    }

    async function fetchSupplies() {
      try {
        const resp = await fetch("supplies_latest.json", { cache: "no-store" });
        if (!resp.ok) throw new Error("supplies fetch failed");
        const data = await resp.json();
        suppliesGlobal = data && data.supplies ? data.supplies : null;
      } catch (err) {
        console.error("Supplies error:", err);
        suppliesGlobal = null;
      }
    }

    async function fetchOracleHistory() {
  try {
    const resp = await fetch("dom_mc_history.json", { cache: "no-store" });
    if (!resp.ok) {
      console.warn("dom_mc_history.json not found or error");
      domMcHistory = [];
      return;
    }
    const data = await resp.json();
    domMcHistory = (data && Array.isArray(data.series)) ? data.series : [];
  } catch (err) {
    console.error("Oracle history error:", err);
    domMcHistory = [];
  }
}



    async function fetchDomBands() {
      try {
        const resp = await fetch("dom_bands_latest.json", { cache: "no-store" });
        if (!resp.ok) throw new Error("dom bands fetch failed");
        domBandsGlobal = await resp.json();
      } catch (err) {
        console.error("Dom bands error:", err);
        domBandsGlobal = null;
      }
    }

    function computeActionForRow(row) {
      const token = row.token;
      if (!token) return "–";

      const upToken = String(token).toUpperCase();

      // No action for BTC or stables
      if (upToken === "BTC" || upToken.includes("USD")) {
        return "–";
      }

      const domRaw = (typeof row.btc_dom === "number") ? row.btc_dom : parseFloat(row.btc_dom || "NaN");
      if (!domRaw || Number.isNaN(domRaw)) return "–";

      const rangeStr = row.range || "";
      // allow: "-", "–", "—", any weird dash
      const m = String(rangeStr).match(/(\d+(?:\.\d+)?)\D+(\d+(?:\.\d+)?)%/);
      if (!m) return "–";

      const minPct = parseFloat(m[1]);
      const maxPct = parseFloat(m[2]);
      if (!(maxPct > minPct)) return "–";

      let pos = (domRaw - minPct) / (maxPct - minPct);
      if (!Number.isFinite(pos)) return "–";
      pos = Math.max(0, Math.min(1, pos));  // clamp [0,1]

      // 40/20/40 style bands:
      // 0.0–0.4  : BTC-heavy zone
      // 0.4–0.6  : Stables (flat)
      // 0.6–1.0  : ALT-heavy zone
      if (pos >= 0.4 && pos <= 0.6) {
        return "Stables";
      }

      let altPct;
      let btcPct;

      if (pos < 0.4) {
        // BTC zone: go from 100% BTC / 0% ALT at pos=0
        // to 50% BTC / 50% ALT at pos=0.4 (contrarian lean)
        const t = pos / 0.4; // 0..1
        btcPct = 100 - Math.round(t * 50); // 100->50
        altPct = 100 - btcPct;             // 0->50
      } else {
        // ALT zone: go from 50% ALT / 50% BTC at pos=0.6
        // to 100% ALT / 0% BTC at pos=1.0
        const t = (pos - 0.6) / 0.4; // 0..1
        altPct = 50 + Math.round(t * 50);  // 50->100
        btcPct = 100 - altPct;             // 50->0
      }

  // Round to nearest 1% and ensure they sum to 100
  altPct = Math.round(altPct);
  if (altPct < 0) altPct = 0;
  if (altPct > 100) altPct = 100;
  btcPct = 100 - altPct;

  return `${altPct}/${btcPct}`;

    }

    async function fetchPrices() {
      try {
        const resp = await fetch("prices_latest.json", { cache: "no-store" });
        if (!resp.ok) throw new Error("prices fetch failed");
        const data = await resp.json();

        const metaEl = document.getElementById("meta-date");
        if (metaEl && data && data.timestamp) {
          metaEl.textContent = formatDateTime(data.timestamp);
        }

        const tbody = document.getElementById("prices-tbody");
        tbody.innerHTML = "";

        const rows = Array.isArray(data.rows) ? data.rows : [];
        pricesRowsGlobal = rows;

        rows.forEach(row => {
          const tr = document.createElement("tr");

          const tdToken = document.createElement("td");
          tdToken.className = "token-col";
          tdToken.textContent = row.token || "";
          tr.appendChild(tdToken);

          const tdPrice = document.createElement("td");
          tdPrice.className = "center";
          const priceVal = typeof row.price === "number" ? row.price : parseFloat(row.price || "0");
          if (!Number.isNaN(priceVal) && priceVal > 0) {
            if (priceVal >= 1000) {
              tdPrice.textContent = "$" + Math.round(priceVal).toLocaleString();
            } else {
              tdPrice.textContent = "$" + priceVal.toFixed(2);
            }
          } else {
            tdPrice.textContent = "–";
          }
          tr.appendChild(tdPrice);

          const tdChange = document.createElement("td");
          tdChange.className = "center";
          const ch = typeof row.change_24h === "number"
            ? row.change_24h
            : parseFloat(row.change_24h || "0");
          if (Number.isNaN(ch)) {
            tdChange.textContent = "–";
            tdChange.classList.add("price-neutral");
          } else {
            const sign = ch > 0 ? "+" : "";
            tdChange.textContent = `${sign}${ch.toFixed(1)}%`;
            if (ch > 0) {
              tdChange.classList.add("price-positive");
            } else if (ch < 0) {
              tdChange.classList.add("price-negative");
            } else {
              tdChange.classList.add("price-neutral");
            }
          }
          tr.appendChild(tdChange);

          const tdDom = document.createElement("td");
          tdDom.className = "center";
          const dom = typeof row.btc_dom === "number" ? row.btc_dom : null;
          if (dom === null || Number.isNaN(dom)) {
            tdDom.textContent = "–";
          } else {
            tdDom.textContent = dom.toFixed(1) + "%";
          }
          tr.appendChild(tdDom);

          const tdRange = document.createElement("td");
          tdRange.className = "center";
          tdRange.textContent = row.range || "–";
          tr.appendChild(tdRange);

          // NEW: Action column
          const tdAction = document.createElement("td");
          tdAction.className = "center";
          tdAction.textContent = computeActionForRow(row);
          tr.appendChild(tdAction);

          tbody.appendChild(tr);
        });

        buildOracleMenus();
        updateOracle();
      } catch (err) {
        console.error("Prices error:", err);
        const tbody = document.getElementById("prices-tbody");
        tbody.innerHTML = "";
      }
    }

            async function fetchKnifecatcher() {
      try {
        // --- Knifecatcher #1: existing rebalancer ---
        const resp = await fetch("knifecatcher_latest.json", { cache: "no-store" });
        if (!resp.ok) throw new Error("knifecatcher fetch failed");
        const data = await resp.json();

        const balanceEl = document.getElementById("kc-balance");
        const compareEl = document.getElementById("kc-compare");

        if (data && balanceEl && compareEl) {
          const base = typeof data.base_balance_usd === "number"
            ? data.base_balance_usd
            : parseFloat(data.base_balance_usd || "0");

          const portVal = typeof data.portfolio_value === "number"
            ? data.portfolio_value
            : parseFloat(data.portfolio_value || "0");

          const btcVal = typeof data.btc_value === "number"
            ? data.btc_value
            : parseFloat(data.btc_value || "0");

          if (!Number.isNaN(portVal) && portVal >= 0) {
            balanceEl.textContent = "$" + portVal.toFixed(2);
          }

          let algoRoi = null;
          let btcRoi = null;

          if (base && base > 0) {
            algoRoi = (portVal / base) - 1;
            btcRoi = (btcVal / base) - 1;
          }

          function fmtPct(x) {
            if (x === null || Number.isNaN(x)) return "--.--%";
            const pct = x * 100;
            const sign = pct > 0 ? "+" : "";
            return sign + pct.toFixed(1) + "%";
          }

          const algoStr = fmtPct(algoRoi);
          const btcStr = fmtPct(btcRoi);
          compareEl.textContent = algoStr + " vs " + btcStr;
        }

        // --- Knifecatcher #2: DOM hourly model (sim) ---
        const domBalanceEl = document.getElementById("kc2-balance");
        const domRoiEl = document.getElementById("kc2-roi");
        const domSubEl = document.getElementById("kc2-subline");

        if (domBalanceEl && domRoiEl && domSubEl) {
          try {
            const resp2 = await fetch("dom_signals_hourly.json", { cache: "no-store" });
            if (!resp2.ok) throw new Error("dom signals fetch failed");
            const sig = await resp2.json();

            if (sig && sig.position) {
              const pos = sig.position;

              const equityUsd = (typeof sig.equity_usd === "number")
                ? sig.equity_usd
                : parseFloat(sig.equity_usd || "NaN");

              const roiFrac = (typeof sig.roi_frac === "number")
                ? sig.roi_frac
                : parseFloat(sig.roi_frac || "NaN");

              const token = (pos.token || "NONE").toString().toUpperCase();
              const type = (pos.type || "").toString().toUpperCase();
              const hmiOverride = !!pos.hmi_override;

              const entryPrice = (typeof pos.entry_price === "number")
                ? pos.entry_price
                : parseFloat(pos.entry_price || "NaN");

              const targetPrice = (typeof pos.target_price === "number")
                ? pos.target_price
                : parseFloat(pos.target_price || "NaN");

              function fmtUsd(x) {
                if (x === null || Number.isNaN(x)) return "--";
                return x.toFixed(2);
              }

              function fmtPct(x) {
                if (x === null || Number.isNaN(x)) return "--.--%";
                const pct = x * 100;
                const sign = pct > 0 ? "+" : "";
                return sign + pct.toFixed(1) + "%";
              }

              if (!Number.isNaN(equityUsd)) {
                domBalanceEl.textContent = "$" + fmtUsd(equityUsd);
              } else {
                domBalanceEl.textContent = "$--.--";
              }

              if (roiFrac !== null && !Number.isNaN(roiFrac)) {
                domRoiEl.textContent = fmtPct(roiFrac);
              } else {
                domRoiEl.textContent = "--.--%";
              }

              // Build subline: token | Entry | Target OR Stables
              let subText = "Stables";
              if (!hmiOverride && type !== "STABLES" && token !== "NONE") {
                subText = token + " | Entry: $" + fmtUsd(entryPrice);
                if (!Number.isNaN(targetPrice)) {
                  subText += " | Target: $" + fmtUsd(targetPrice);
                }
              } else {
                // Stables (either real, or due to HMI override)
                if (roiFrac !== null && !Number.isNaN(roiFrac)) {
                  subText = "Stables | ROI: " + fmtPct(roiFrac);
                } else {
                  subText = "Stables";
                }
              }

              domSubEl.textContent = subText;
            }
          } catch (err2) {
            console.error("DOM signals error:", err2);
          }
        }
      } catch (err) {
        console.error("Knifecatcher error:", err);
      }
    }



    // -------- Oracle helpers --------

    function formatTokenLabel(token) {
      if (token === "ALTS") return "Alts";
      const lower = token.toLowerCase();
      return lower.charAt(0).toUpperCase() + lower.slice(1);
    }

    function formatTokenSetLabel(tokens) {
      if (tokens.length === 0) return "Select";
      if (tokens.includes("ALTS")) return "Alts";
      if (tokens.length === 1) return formatTokenLabel(tokens[0]);
      return tokens.map(formatTokenLabel).join("");
    }

    function getLiveMC(token) {
      const row = pricesRowsGlobal.find(r => r.token === token);
      if (!row) return 0;
      const v = row.mc;
      if (typeof v === "number") return v;
      const f = parseFloat(v || "0");
      return Number.isNaN(f) ? 0 : f;
    }

    function getSupply(token) {
      if (!suppliesGlobal) return 0;
      const entry = suppliesGlobal[token];
      if (!entry) return 0;
      const val = entry.circulating_supply;
      if (typeof val === "number") return val;
      const f = parseFloat(val || "0");
      return Number.isNaN(f) ? 0 : f;
    }

    

    function sortTokensByMC(tokens) {
      const arr = [...tokens];
      arr.sort((a, b) => {
        const aMC = getLiveMC(a);
        const bMC = getLiveMC(b);
        if (aMC > bMC) return -1;
        if (aMC < bMC) return 1;
        return a.localeCompare(b);
      });
      return arr;
    }

    function computeOracleDomAndRange(xTokens, yTokens) {
  // Expand a side, handling ALTS and removing overlaps with the other side
  function expandSideX(tokens) {
    if (tokens.includes("ALTS")) {
      // ALTS shouldn't really be on X, but be defensive
      return ORACLE_TOKENS.filter((t) => t !== "BTC");
    }
    return tokens;
  }

  // fullX is computed first so Y can exclude those tokens
  const fullX = Array.from(new Set(expandSideX(xTokens)));

  function expandSideY(tokens) {
    let base;
    if (tokens.includes("ALTS")) {
      // ALTS = all non-BTC tokens
      base = ORACLE_TOKENS.filter((t) => t !== "BTC");
    } else {
      base = tokens;
    }
    const xSet = new Set(fullX);
    // never include tokens that are already on X
    return base.filter((t) => !xSet.has(t));
  }

  const fullY = Array.from(new Set(expandSideY(yTokens)));

  const labelSide = (tokens, expanded) => {
    if (tokens.length === 1 && tokens[0] === "ALTS") {
      return "Alts";
    }
    if (tokens.length === 1) {
      return prettyName(tokens[0]);
    }
    if (!expanded || expanded.length === 0) return "–";
    if (expanded.length === 1) return prettyName(expanded[0]);
    return expanded.map(prettyName).join(" + ");
  };

  const labelX = labelSide(xTokens, fullX);
  const labelY = labelSide(yTokens, fullY);

  if (!fullX.length || !fullY.length) {
    return {
      domNow: null,
      domMin: null,
      domMax: null,
      labelX,
      labelY,
      days: 0,
    };
  }

  const xSet = new Set(fullX);
  const ySet = new Set(fullY);

  // --- current dominance from latest prices_latest.json ---
  const mcNow = {};
  pricesRowsGlobal.forEach((row) => {
    mcNow[row.token] = row.mc || 0;
  });

  const sumMc = (set, mcObj) => {
    let s = 0;
    set.forEach((t) => {
      s += mcObj[t] || 0;
    });
    return s;
  };

  const mcXnow = sumMc(xSet, mcNow);
  const mcYnow = sumMc(ySet, mcNow);
  const denomNow = mcXnow + mcYnow;
  const domNow =
    denomNow > 0 && Number.isFinite(denomNow)
      ? (100 * mcXnow) / denomNow
      : null;

  // --- historical min/max dominance from dom_mc_history.json ---
  let domMin = null;
  let domMax = null;
  let days = 0;

  if (domMcHistory && domMcHistory.length > 0) {
    for (const row of domMcHistory) {
      const mc = row.mc || {};
      const mcX = sumMc(xSet, mc);
      const mcY = sumMc(ySet, mc);
      const denom = mcX + mcY;
      if (!denom) continue;
      const d = (100 * mcX) / denom;
      if (!Number.isFinite(d)) continue;
      if (domMin === null || d < domMin) domMin = d;
      if (domMax === null || d > domMax) domMax = d;
      days++;
    }
  }

  // Fallback: if we have no history (or degenerate), but this is BTC vs single ALT,
  // use the per-token BTC-vs-ALT range we already stored in prices_latest.json.
  if (
    (domMin === null || domMax === null) &&
    xSet.size === 1 &&
    xSet.has("BTC") &&
    ySet.size === 1
  ) {
    const alt = Array.from(ySet)[0];
    const row = pricesRowsGlobal.find((r) => r.token === alt);
    if (row && row.range) {
      const parts = row.range
        .replace(/%/g, "")
        .split(/[–-]/)
        .map((s) => parseFloat(s.trim()));
      if (parts.length === 2 && parts.every((v) => !Number.isNaN(v))) {
        domMin = parts[0];
        domMax = parts[1];
      }
    }
  }

  // Still nothing? Just fall back to the current dominance.
  if (domMin === null || domMax === null) {
    domMin = domNow;
    domMax = domNow;
  }

  return {
    domNow,
    domMin,
    domMax,
    labelX,
    labelY,
    days,
  };
}



    function buildOracleMenus() {
      const xMenu = document.getElementById("oracle-x-menu");
      const yMenu = document.getElementById("oracle-y-menu");
      const xLabel = document.getElementById("oracle-x-label");
      const yLabel = document.getElementById("oracle-y-label");
      const xPill = document.getElementById("oracle-x-pill");
      const yPill = document.getElementById("oracle-y-pill");

      if (!xMenu || !yMenu || !xLabel || !yLabel || !xPill || !yPill) return;

      const xOrder = ["BTC", ...ORACLE_TOKENS.filter(t => t !== "BTC")];
      const yOrder = ["ALTS", "BTC", ...ORACLE_TOKENS.filter(t => t !== "BTC")];

      const xIsPureBTC = (oracleSelectedX.length === 1 && oracleSelectedX[0] === "BTC");

      xMenu.innerHTML = "";
      yMenu.innerHTML = "";

        xOrder.forEach((tok) => {
    if (oracleSelectedY.includes(tok)) return; // don’t show tokens already on Y
    const div = document.createElement("div");


        const div = document.createElement("div");
        div.className = "oracle-option";
        div.dataset.token = tok;

        const box = document.createElement("div");
        box.className = "oracle-option-box";

        const tick = document.createElement("span");
        tick.className = "oracle-option-tick";
        tick.textContent = "✓";

        const label = document.createElement("span");
        label.className = "oracle-option-label";
        label.textContent = formatTokenLabel(tok);

        box.appendChild(tick);
        div.appendChild(box);
        div.appendChild(label);

        if (oracleSelectedX.includes(tok)) {
          div.classList.add("selected");
        }

        div.addEventListener("click", (e) => {
          e.stopPropagation();
          if (tok === "BTC") {
            if (oracleSelectedX.includes("BTC")) {
              oracleSelectedX = oracleSelectedX.filter(t => t !== "BTC");
            } else {
              oracleSelectedX = ["BTC"];
            }
          } else {
            oracleSelectedX = oracleSelectedX.filter(t => t !== "BTC");
            if (oracleSelectedX.includes(tok)) {
              oracleSelectedX = oracleSelectedX.filter(t => t !== tok);
            } else {
              oracleSelectedX = [...oracleSelectedX, tok];
            }
          }
          Array.from(xMenu.querySelectorAll(".oracle-option")).forEach(opt => {
            const t = opt.dataset.token;
            opt.classList.toggle("selected", oracleSelectedX.includes(t));
          });
          xLabel.textContent = formatTokenSetLabel(oracleSelectedX);
          buildOracleMenus();
          updateOracle();
        });

        xMenu.appendChild(div);
      });

      const xClear = document.createElement("div");
      xClear.className = "oracle-clear";
      xClear.textContent = "Clear";
      xClear.addEventListener("click", (e) => {
        e.stopPropagation();
        oracleSelectedX = [];
        Array.from(xMenu.querySelectorAll(".oracle-option")).forEach(opt => {
          opt.classList.remove("selected");
        });
        xLabel.textContent = "Select";
        buildOracleMenus();
        updateOracle();
      });
      xMenu.appendChild(xClear);

        yOrder.forEach((tok) => {
    if (tok === "ALTS" && !xIsPureBTC) return;
    if (tok !== "ALTS" && oracleSelectedX.includes(tok)) return; // don’t show tokens already on X


        const div = document.createElement("div");
        div.className = "oracle-option";
        div.dataset.token = tok;

        const box = document.createElement("div");
        box.className = "oracle-option-box";

        const tick = document.createElement("span");
        tick.className = "oracle-option-tick";
        tick.textContent = "✓";

        const label = document.createElement("span");
        label.className = "oracle-option-label";
        label.textContent = formatTokenLabel(tok);

        box.appendChild(tick);
        div.appendChild(box);
        div.appendChild(label);

        if (oracleSelectedY.includes(tok)) {
          div.classList.add("selected");
        }

        div.addEventListener("click", (e) => {
          e.stopPropagation();
          if (tok === "ALTS") {
            oracleSelectedY = ["ALTS"];
          } else {
            oracleSelectedY = oracleSelectedY.filter(t => t !== "ALTS");
            if (oracleSelectedY.includes(tok)) {
              oracleSelectedY = oracleSelectedY.filter(t => t !== tok);
            } else {
              oracleSelectedY = [...oracleSelectedY, tok];
            }
            if (oracleSelectedY.length === 0) {
              oracleSelectedY = [];
            }
          }
          Array.from(yMenu.querySelectorAll(".oracle-option")).forEach(opt => {
            const t = opt.dataset.token;
            opt.classList.toggle("selected", oracleSelectedY.includes(t));
          });
          yLabel.textContent = formatTokenSetLabel(oracleSelectedY);
          buildOracleMenus();
          updateOracle();
        });

        yMenu.appendChild(div);
      });

      const yClear = document.createElement("div");
      yClear.className = "oracle-clear";
      yClear.textContent = "Clear";
      yClear.addEventListener("click", (e) => {
        e.stopPropagation();
        oracleSelectedY = [];
        Array.from(yMenu.querySelectorAll(".oracle-option")).forEach(opt => {
          opt.classList.remove("selected");
        });
        yLabel.textContent = "Select";
        buildOracleMenus();
        updateOracle();
      });
      yMenu.appendChild(yClear);

      xLabel.textContent = formatTokenSetLabel(oracleSelectedX);
      yLabel.textContent = formatTokenSetLabel(oracleSelectedY);

      function closeAllDropdowns() {
        xMenu.classList.remove("open");
        yMenu.classList.remove("open");
      }

      xPill.onclick = (e) => {
        e.stopPropagation();
        const isOpen = xMenu.classList.contains("open");
        closeAllDropdowns();
        if (!isOpen) xMenu.classList.add("open");
      };
      yPill.onclick = (e) => {
        e.stopPropagation();
        const isOpen = yMenu.classList.contains("open");
        closeAllDropdowns();
        if (!isOpen) yMenu.classList.add("open");
      };

      xMenu.addEventListener("click", (e) => e.stopPropagation());
      yMenu.addEventListener("click", (e) => e.stopPropagation());

      document.addEventListener("click", () => {
        closeAllDropdowns();
      });
    }

    async function updateOracle() {
      const mainEl = document.getElementById("oracle-main-line");
      const subEl = document.getElementById("oracle-sub-line");
      const rangeEl = document.getElementById("oracle-range-line");
      const errEl = document.getElementById("oracle-error");

      if (!mainEl || !subEl || !rangeEl || !errEl) return;

      const res = computeOracleDomAndRange(oracleSelectedX, oracleSelectedY);

      if (!res.ok) {
        mainEl.innerHTML = '<span class="dom-value">--</span><span class="dom-label">Select X and Y</span>';
        subEl.innerHTML = 'Market caps: <span>–</span>';
        rangeEl.innerHTML = 'Range: <span>–</span>';
        errEl.textContent = res.reason || "";
        return;
      }

      errEl.textContent = "";

      const domVal = res.domNow;
      const domStr = domVal != null && !Number.isNaN(domVal) ? domVal.toFixed(1) : "--";

      const label = `${res.labelX} vs ${res.labelY}`;
      mainEl.innerHTML = `<span class="dom-value">${domStr}</span><span class="dom-label">${label}</span>`;

      const mcXfmt = formatMC(res.mcX || 0);
      const mcYfmt = formatMC(res.mcY || 0);
      subEl.innerHTML = `Market caps: <span>${mcXfmt} vs ${mcYfmt}</span>`;

      let rangeSpan = "–";
      if (res.domMin != null && res.domMax != null && res.domMax > res.domMin) {
        const mn = Math.round(res.domMin);
        const mx = Math.round(res.domMax);
        rangeSpan = `${mn}%–${mx}%`;
      }
      rangeEl.innerHTML = `Range: <span>${rangeSpan}</span>`;
    }

    (function init() {
      fetchHMI();
      fetchSupplies()
        .then(fetchDomHistory)
        .then(fetchDomBands)
        .then(fetchPrices)
        .then(fetchKnifecatcher);
    })();
  </script>
</body>
</html>
