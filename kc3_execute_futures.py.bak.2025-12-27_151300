#!/usr/bin/env python3
"""
KC3 Futures Executor (USD‚ìà-M) ‚Äî FIXED + SIMPLE

Reads desired position from:
  1) /var/www/bbotpat_live/kc3_exec_desired.json   (override, for forcing)
  2) /var/www/bbotpat_live/kc3_latest.json        (paper agent output)

Desired format:
  {"position": {"side": "LONG"|"SHORT", "token": "UNI"}}

Key fixes:
- Correct balance lookup for multi-asset futures:
  Prefer /fapi/v2/account.assets[].availableBalance for QUOTE_ASSET or symbol.marginAsset
  Fallback to /fapi/v2/balance rows
  Final fallback to /fapi/v2/account.availableBalance (aggregate)

- Correct LOT_SIZE precision:
  Uses exchangeInfo LOT_SIZE stepSize+minQty and FLOORS quantity exactly (Decimal).

- No spam:
  Acts only on desired change, and stores state in:
    /root/bbotpat_live/data/kc3_futures_exec_state.json
  On error, backs off FAIL_BACKOFF_SEC seconds.

- Telegram:
  Sends OPEN/CLOSE success messages, and throttled ERROR pings.

Environment:
  BINANCE_API_KEY
  BINANCE_API_SECRET
  BINANCE_FUTURES_BASE_URL   (default https://fapi.binance.com)
  LIVE_TRADING_KC3           (0/1)
  KC3_SYMBOL_SUFFIX          (default USDT, you set USDC)
  KC3_QUOTE_ASSET            (default USDT, you set USDC)
  KC3_LEVERAGE               (default 1)
  KC3_MAX_NOTIONAL           (0 = full available, else cap)
  KC3_POLL_SEC               (default 3)
  KC3_FAIL_BACKOFF_SEC       (default 30)

  TG_BOT_TOKEN, TG_CHAT_ID   (optional)
"""

import os
import json
import time
import hmac
import hashlib
import urllib.parse
from pathlib import Path
from datetime import datetime, timezone
from decimal import Decimal, ROUND_DOWN, getcontext

import requests

# ---------- Paths ----------
KC3_LATEST = Path("/var/www/bbotpat_live/kc3_latest.json")
KC3_OVERRIDE = Path("/var/www/bbotpat_live/kc3_exec_desired.json")

STATE_DIR = Path("/root/bbotpat_live/data")
STATE_DIR.mkdir(parents=True, exist_ok=True)
STATE_PATH = STATE_DIR / "kc3_futures_exec_state.json"

# ---------- Config ----------
BASE_URL = os.getenv("BINANCE_FUTURES_BASE_URL", "https://fapi.binance.com").rstrip("/")
API_KEY = os.getenv("BINANCE_API_KEY", "")
API_SECRET = os.getenv("BINANCE_API_SECRET", "")

LIVE_TRADING = str(os.getenv("LIVE_TRADING_KC3", "0")).strip() in ("1", "true", "True", "YES", "yes")

QUOTE_ASSET = os.getenv("KC3_QUOTE_ASSET", "USDT").upper().strip()
SYMBOL_SUFFIX = os.getenv("KC3_SYMBOL_SUFFIX", "USDT").upper().strip()
LEVERAGE = int(os.getenv("KC3_LEVERAGE", "1"))
MAX_NOTIONAL = float(os.getenv("KC3_MAX_NOTIONAL", "0") or "0")  # 0 => full available
POLL_SEC = float(os.getenv("KC3_POLL_SEC", "3") or "3")
FAIL_BACKOFF_SEC = float(os.getenv("KC3_FAIL_BACKOFF_SEC", "30") or "30")

TG_BOT_TOKEN = os.getenv("TG_BOT_TOKEN", "").strip()
TG_CHAT_ID = os.getenv("TG_CHAT_ID", "").strip()

# more precision than we need, but safe for Decimal ops
getcontext().prec = 50


def utc_now_iso() -> str:
    return datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")


def log(msg: str):
    print(f"[{utc_now_iso()}] {msg}", flush=True)


def tg_send(text: str):
    if not (TG_BOT_TOKEN and TG_CHAT_ID):
        return
    try:
        url = f"https://api.telegram.org/bot{TG_BOT_TOKEN}/sendMessage"
        requests.post(url, json={"chat_id": TG_CHAT_ID, "text": text}, timeout=10)
    except Exception:
        pass


def safe_read_json(path: Path):
    try:
        if not path.exists():
            return None
        return json.loads(path.read_text())
    except Exception:
        return None


def safe_write_json(path: Path, obj):
    tmp = path.with_suffix(path.suffix + ".tmp")
    tmp.write_text(json.dumps(obj, indent=2))
    tmp.replace(path)


def require_creds():
    if not API_KEY or not API_SECRET:
        raise RuntimeError("Missing BINANCE_API_KEY or BINANCE_API_SECRET in environment")


def _sign(params: dict) -> dict:
    params = dict(params)
    params["timestamp"] = int(time.time() * 1000)
    params["recvWindow"] = 5000
    qs = urllib.parse.urlencode(params, doseq=True)
    sig = hmac.new(API_SECRET.encode(), qs.encode(), hashlib.sha256).hexdigest()
    params["signature"] = sig
    return params


def _request(method: str, path: str, params=None, signed=False):
    if params is None:
        params = {}
    url = BASE_URL + path
    headers = {}
    if signed:
        require_creds()
        params = _sign(params)
        headers["X-MBX-APIKEY"] = API_KEY

    r = requests.request(method, url, params=params, headers=headers, timeout=15)
    if r.status_code != 200:
        raise RuntimeError(f"{method} {path} failed {r.status_code}: {r.text}")
    return r.json()


# ---------- Binance endpoints ----------
def exchange_info():
    return _request("GET", "/fapi/v1/exchangeInfo", signed=False)


def set_leverage(symbol: str, lev: int):
    return _request("POST", "/fapi/v1/leverage", params={"symbol": symbol, "leverage": lev}, signed=True)


def account_v2():
    # returns aggregate and assets[] list
    return _request("GET", "/fapi/v2/account", signed=True)


def balance_v2():
    # returns list of asset rows
    return _request("GET", "/fapi/v2/balance", signed=True)


def position_risk():
    return _request("GET", "/fapi/v2/positionRisk", signed=True)


def mark_price(symbol: str):
    return _request("GET", "/fapi/v1/premiumIndex", params={"symbol": symbol}, signed=False)


def place_market_order(symbol: str, side: str, qty_str: str, reduce_only: bool = False):
    params = {
        "symbol": symbol,
        "side": side,  # BUY opens/increases long; SELL opens/increases short
        "type": "MARKET",
        "quantity": qty_str,
    }
    if reduce_only:
        params["reduceOnly"] = "true"
    return _request("POST", "/fapi/v1/order", params=params, signed=True)


# ---------- Symbol utilities ----------
_EXINFO_CACHE = {"ts": 0.0, "data": None}
_SYMBOL_META = {}  # symbol -> dict(stepSize, minQty, marginAsset)


def symbol_from_token(token: str) -> str:
    return f"{token.upper().strip()}{SYMBOL_SUFFIX}"


def _refresh_exchange_info(force=False):
    now = time.time()
    if force or (_EXINFO_CACHE["data"] is None) or (now - _EXINFO_CACHE["ts"] > 300):
        _EXINFO_CACHE["data"] = exchange_info()
        _EXINFO_CACHE["ts"] = now
    return _EXINFO_CACHE["data"]


def get_symbol_meta(symbol: str):
    if symbol in _SYMBOL_META:
        return _SYMBOL_META[symbol]

    ex = _refresh_exchange_info()
    symbols = ex.get("symbols", [])
    meta = None
    for s in symbols:
        if s.get("symbol") == symbol:
            # LOT_SIZE filter contains stepSize and minQty
            step = None
            minq = None
            for f in s.get("filters", []):
                if f.get("filterType") == "LOT_SIZE":
                    step = f.get("stepSize")
                    minq = f.get("minQty")
                    break
            margin_asset = s.get("marginAsset") or s.get("quoteAsset") or QUOTE_ASSET
            if step is None or minq is None:
                raise RuntimeError(f"Missing LOT_SIZE for {symbol}")
            meta = {
                "stepSize": str(step),
                "minQty": str(minq),
                "marginAsset": str(margin_asset).upper(),
            }
            break

    if meta is None:
        raise RuntimeError(f"Symbol not found in exchangeInfo: {symbol}")

    _SYMBOL_META[symbol] = meta
    return meta


def floor_to_step(qty: Decimal, step: Decimal) -> Decimal:
    # Floors qty to a multiple of step: floor(qty/step)*step
    if step <= 0:
        return qty
    n = (qty / step).to_integral_value(rounding=ROUND_DOWN)
    return n * step


def compute_qty_from_notional(symbol: str, notional: Decimal) -> str:
    mp = mark_price(symbol)
    px = Decimal(str(mp.get("markPrice", "0")))
    if px <= 0:
        raise RuntimeError(f"Bad mark price for {symbol}: {mp}")

    meta = get_symbol_meta(symbol)
    step = Decimal(meta["stepSize"])
    minq = Decimal(meta["minQty"])

    raw_qty = notional / px
    floored = floor_to_step(raw_qty, step)

    if floored < minq:
        raise RuntimeError(f"Computed qty {floored} < minQty {minq} for {symbol} (notional={notional}, px={px})")

    # Binance accepts quantity as string; keep as plain decimal without exponent
    qty_str = format(floored.normalize(), "f")
    return qty_str


# ---------- Desired + State ----------
def read_desired():
    d = safe_read_json(KC3_OVERRIDE)
    if isinstance(d, dict) and isinstance(d.get("position"), dict):
        return d, "override"

    d = safe_read_json(KC3_LATEST)
    if isinstance(d, dict) and isinstance(d.get("position"), dict):
        return d, "latest"

    return None, None


def load_state():
    st = safe_read_json(STATE_PATH)
    if not isinstance(st, dict):
        st = {}
    st.setdefault("last_desired_key", None)
    st.setdefault("last_symbol", None)
    st.setdefault("last_error_ts", 0.0)
    st.setdefault("error_notified_ts", 0.0)
    return st


def save_state(st: dict):
    safe_write_json(STATE_PATH, st)


def desired_key_from_pos(pos: dict) -> str:
    token = str(pos.get("token", "")).upper().strip()
    side = str(pos.get("side", "")).upper().strip()
    return f"{side}:{token}"


# ---------- Positions + balance ----------
def get_current_position_amt(symbol: str) -> Decimal:
    pr = position_risk()
    if isinstance(pr, list):
        for row in pr:
            if row.get("symbol") == symbol:
                try:
                    return Decimal(str(row.get("positionAmt", "0")))
                except Exception:
                    return Decimal("0")
    return Decimal("0")


def get_available_balance_for_asset(asset: str) -> Decimal:
    asset = asset.upper().strip()

    # 1) Prefer /fapi/v2/account assets[] (best for multi-asset margin)
    try:
        acc = account_v2()
        assets = acc.get("assets", [])
        if isinstance(assets, list):
            for row in assets:
                if str(row.get("asset", "")).upper() == asset:
                    v = row.get("availableBalance")
                    if v is None:
                        v = row.get("walletBalance")
                    if v is not None:
                        return Decimal(str(v))
        # 2) Fallback: /fapi/v2/balance list rows
        bal = balance_v2()
        if isinstance(bal, list):
            for row in bal:
                if str(row.get("asset", "")).upper() == asset:
                    v = row.get("availableBalance") or row.get("balance")
                    if v is not None:
                        return Decimal(str(v))
        # 3) Final fallback: aggregate account.availableBalance (USDT-equivalent)
        v = acc.get("availableBalance")
        if v is not None:
            return Decimal(str(v))
    except Exception as e:
        # If private endpoints fail, treat as zero
        log(f"Warn: balance lookup failed: {e}")

    return Decimal("0")


# ---------- Main ----------
def main():
    st = load_state()

    log(f"KC3 Futures Executor starting. LIVE_TRADING_KC3={LIVE_TRADING}")
    log(f"BASE_URL={BASE_URL} QUOTE_ASSET={QUOTE_ASSET} SYMBOL_SUFFIX={SYMBOL_SUFFIX} LEV={LEVERAGE} MAX_NOTIONAL={MAX_NOTIONAL}")
    log(f"DESIRED override path: {KC3_OVERRIDE} (preferred), fallback: {KC3_LATEST}")

    # Ensure creds for signed calls (we always query private endpoints)
    require_creds()

    while True:
        try:
            desired, src = read_desired()
            if not desired:
                time.sleep(POLL_SEC)
                continue

            pos = desired.get("position")
            if not isinstance(pos, dict):
                time.sleep(POLL_SEC)
                continue

            token = str(pos.get("token", "")).upper().strip()
            side = str(pos.get("side", "")).upper().strip()  # LONG / SHORT

            if not token or side not in ("LONG", "SHORT"):
                time.sleep(POLL_SEC)
                continue

            desired_key = desired_key_from_pos(pos)
            if desired_key == st.get("last_desired_key"):
                # no change -> do nothing
                time.sleep(POLL_SEC)
                continue

            symbol = symbol_from_token(token)

            # set leverage once per new symbol
            if symbol != st.get("last_symbol"):
                try:
                    set_leverage(symbol, LEVERAGE)
                    log(f"Leverage set OK for {symbol} => {LEVERAGE}x")
                except Exception as e:
                    log(f"Warn: leverage set failed for {symbol}: {e}")
                st["last_symbol"] = symbol

            meta = get_symbol_meta(symbol)
            margin_asset = meta["marginAsset"] or QUOTE_ASSET

            cur_amt = get_current_position_amt(symbol)  # + long, - short
            desired_is_long = (side == "LONG")

            # If we have an opposite position, close it first
            if cur_amt != 0:
                cur_is_long = cur_amt > 0
                if cur_is_long != desired_is_long:
                    close_side = "SELL" if cur_amt > 0 else "BUY"
                    close_qty = format(abs(cur_amt).normalize(), "f")
                    msg = f"KC3 flip: closing {symbol} amt={cur_amt} via {close_side} qty={close_qty} (src={src})"
                    log(msg)
                    if LIVE_TRADING:
                        place_market_order(symbol, close_side, close_qty, reduce_only=True)
                        tg_send("‚úÖ " + msg)
                else:
                    # already aligned; just accept state and stop
                    log(f"KC3 aligned already: {symbol} desired={side} amt={cur_amt} (src={src})")
                    st["last_desired_key"] = desired_key
                    save_state(st)
                    time.sleep(POLL_SEC)
                    continue

            # Determine notional
            avail = get_available_balance_for_asset(margin_asset)
            if avail <= Decimal("0"):
                raise RuntimeError(f"Not enough available {margin_asset} to open (avail={avail}).")

            notional = avail
            if MAX_NOTIONAL > 0:
                cap = Decimal(str(MAX_NOTIONAL))
                if notional > cap:
                    notional = cap

            qty_str = compute_qty_from_notional(symbol, notional)

            open_side = "BUY" if desired_is_long else "SELL"
            msg = f"KC3 open: {side} {symbol} margin={margin_asset} notional~{notional} qty={qty_str} LIVE={LIVE_TRADING} (src={src})"
            log(msg)

            if LIVE_TRADING:
                place_market_order(symbol, open_side, qty_str, reduce_only=False)
                tg_send("‚úÖ " + msg)
            else:
                tg_send("üü¶ (dry-run) " + msg)

            st["last_desired_key"] = desired_key
            st["last_error_ts"] = 0.0
            save_state(st)

        except Exception as e:
            now = time.time()
            st["last_error_ts"] = now
            save_state(st)
            emsg = f"KC3 futures ERROR: {e}"
            log(emsg)

            # Throttle telegram error spam
            if TG_BOT_TOKEN and TG_CHAT_ID:
                if now - float(st.get("error_notified_ts", 0.0)) > FAIL_BACKOFF_SEC:
                    tg_send("‚ùå " + emsg)
                    st["error_notified_ts"] = now
                    save_state(st)

            time.sleep(FAIL_BACKOFF_SEC)
            continue

        time.sleep(POLL_SEC)


if __name__ == "__main__":
    main()
